# ğŸ“Œ Valor PadrÃ£o ğŸ“Œ

''' Um valor padrÃ£o Ã© um valor que serÃ¡ usado para um parÃ¢metro
se nenhum valor for especificado quando a funÃ§Ã£o for chamada.'''

def calcular_volume_comprimento(largura, altura, profundidade=10):
    volume = largura * altura * profundidade
    return volume

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ NoneType ğŸ“Œ

''' None Ã© frequentemente usado para indicar que um valor nÃ£o foi especificado
ou que um objeto nÃ£o possui um valor apropriado.'''

def minha_funcao(a, b=None):
    if b is not None:
        return a + b
    else:
        return a

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Args ğŸ“Œ

''' *args Ã© usado para passar um nÃºmero variÃ¡vel de argumentos posicionais (ou seja, sem nome) para uma funÃ§Ã£o.'''

def minha_funcao(*args):
    for arg in args:
        print(arg)

minha_funcao(1, 2, 3)  # SaÃ­da: 1 2 3
minha_funcao("a", "b", "c")  # SaÃ­da: a b c

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Kwargs ğŸ“Œ

''' **kwargs Ã© usado para passar um nÃºmero variÃ¡vel de argumentos nomeados para uma funÃ§Ã£o.'''

def minha_funcao(**kwargs):
    for chave, valor in kwargs.items():
        print(chave, valor)

minha_funcao(nome="JoÃ£o", idade=25)  # SaÃ­da: nome JoÃ£o, idade 25
minha_funcao(cor="verde", tamanho="grande", material="algodÃ£o")  # SaÃ­da: cor verde, tamanho grande, material algodÃ£o

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Closure ğŸ“Œ

''' Uma closure Ã© uma funÃ§Ã£o que tem acesso a uma variÃ¡vel de um escopo externo, 
mesmo apÃ³s esse escopo ter sido finalizado.'''

def contador():
    contador = 0
    def incrementar_contador():
        nonlocal contador
        contador += 1
        print(contador)
    return incrementar_contador

meu_contador = contador()
meu_contador()  # SaÃ­da: 1
meu_contador()  # SaÃ­da: 2
meu_contador()  # SaÃ­da: 3

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ FunÃ§Ãµes de Ordem Superior ğŸ“Œ

''' FunÃ§Ãµes que retornam outras funÃ§Ãµes sÃ£o chamadas de funÃ§Ãµes de ordem superior.'''

def criar_funcao(mensagem):
    def exibir_mensagem():
        print(mensagem)
    return exibir_mensagem

minha_funcao = criar_funcao("OlÃ¡, mundo!")
minha_funcao()  # SaÃ­da: OlÃ¡, mundo!


#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ FunÃ§Ãµes de Primeira Classe ğŸ“Œ

''' As funÃ§Ãµes em Python sÃ£o de primeira classe, o que significa que elas podem ser atribuÃ­das a variÃ¡veis, 
passadas como argumentos para outras funÃ§Ãµes e retornadas como resultados de outras funÃ§Ãµes.'''

def aplicar_funcao(func, argumento):
    return func(argumento)

def dobrar(numero):
    return numero * 2

resultado = aplicar_funcao(dobrar, 5)
print(resultado)  # SaÃ­da: 10

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ DicionÃ¡rio e MÃ©todos Ãšteis ğŸ“Œ

''' Um dicionÃ¡rio Ã© um tipo de coleÃ§Ã£o que permite armazenar pares chave-valor,
onde cada chave Ã© Ãºnica e associada a um valor correspondente. Ã‰ uma estrutura de dado do tipo de mÃºtavel. '''

cores = {'vermelho': (255, 0, 0), 'verde': (0, 255, 0), 'azul': (0, 0, 255)}

''' Para acessar um valor de um dicionÃ¡rio, basta fornecer a chave correspondente entre colchetes. '''

vermelho = cores['vermelho']
print(vermelho)  # SaÃ­da: (255, 0, 0)

''' Alguns mÃ©todos Ãºteis sÃ£o: 

> keys(): Retorna uma lista de todas as chaves do dicionÃ¡rio.

> values(): Retorna uma lista de todos os valores do dicionÃ¡rio.

> items(): Retorna uma lista de tuplas contendo todas as chaves e seus valores correspondentes no dicionÃ¡rio.

> get(chave, valor_padrÃ£o): Retorna o valor correspondente Ã  chave fornecida. Se a chave nÃ£o estiver presente no dicionÃ¡rio, 
retorna o valor padrÃ£o fornecido (que Ã© None, se nenhum valor padrÃ£o for fornecido).

> pop(chave, valor_padrÃ£o): Remove e retorna o valor correspondente Ã  chave fornecida. Se a chave nÃ£o estiver presente no dicionÃ¡rio, 
retorna o valor padrÃ£o fornecido (ou levanta uma exceÃ§Ã£o KeyError, se nenhum valor padrÃ£o for fornecido).

> update(outro_dicionÃ¡rio): Atualiza o dicionÃ¡rio atual com os pares chave-valor do outro dicionÃ¡rio fornecido.
Se uma chave existir em ambos os dicionÃ¡rios, o valor correspondente no dicionÃ¡rio atual Ã© substituÃ­do pelo valor correspondente no outro dicionÃ¡rio.

> clear(): Remove todos os pares chave-valor do dicionÃ¡rio.'''

#Por exemplo, suponha que tenhamos o seguinte dicionÃ¡rio:

alunos = {'Alice': 8.5, 'Bob': 7.2, 'Charlie': 9.3, 'David': 6.8}

#Podemos usar os mÃ©todos acima para realizar vÃ¡rias operaÃ§Ãµes Ãºteis, como a seguinte:

# Obter todas as chaves do dicionÃ¡rio
chaves = alunos.keys()
print(chaves)  # SaÃ­da: dict_keys(['Alice', 'Bob', 'Charlie', 'David'])

# Obter todos os valores do dicionÃ¡rio
valores = alunos.values()
print(valores)  # SaÃ­da: dict_values([8.5, 7.2, 9.3, 6.8])

# Obter todos os pares chave-valor do dicionÃ¡rio
itens = alunos.items()
print(itens)  # SaÃ­da: dict_items([('Alice', 8.5), ('Bob', 7.2), ('Charlie', 9.3), ('David', 6.8)])

# Obter a nota de Charlie
nota_charlie = alunos.get('Charlie')
print(nota_charlie)  # SaÃ­da: 9.3

# Obter a nota de Eve (com valor padrÃ£o de 0.0)
nota_eve = alunos.get('Eve', 0.0)
print(nota_eve)  # SaÃ­da: 0.0

# Remover o par chave-valor correspondente a 'David'
alunos.pop('David')

# Atualizar o dicionÃ¡rio com novos valores
novos_alunos = {'Eve': 8.9, 'Frank': 7.6}
alunos.update(novos_alunos)

# Remover todos os pares chave-valor do dicionÃ¡rio
alunos.clear()

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Copy e DeepCopy ğŸ“Œ

''' Uma cÃ³pia superficial de um objeto contÃ©m uma nova referÃªncia aos objetos filhos, portanto, a cÃ³pia e o original apontam para os mesmos objetos filhos. 
Por outro lado, uma cÃ³pia profunda de um objeto contÃ©m novas cÃ³pias dos objetos filhos, recursivamente.
'''

import copy

original = [[1, 2], [3, 4]]
copia_superficial = copy.copy(original)
copia_profunda = copy.deepcopy(original)

# Altera um valor no objeto filho compartilhado
original[0][1] = 5

# A alteraÃ§Ã£o Ã© refletida na cÃ³pia superficial
print(copia_superficial)  # SaÃ­da: [[1, 5], [3, 4]]

# A alteraÃ§Ã£o nÃ£o Ã© refletida na cÃ³pia profunda
print(copia_profunda)  # SaÃ­da: [[1, 2], [3, 4]]

''' Observe que a alteraÃ§Ã£o em original Ã© refletida em copia_superficial, mas nÃ£o em copia_profunda. 
Isso ocorre porque copia_superficial compartilha os objetos filhos com original, enquanto copia_profunda contÃ©m novas cÃ³pias dos objetos filhos.'''

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Tipo Set e suas Peculiaridades ğŸ“Œ

''' Em Python, um set Ã© um tipo de coleÃ§Ã£o de elementos Ãºnicos e nÃ£o ordenados. Um conjunto Ã© criado usando chaves {} ou a funÃ§Ã£o set() e pode conter elementos de 
qualquer tipo imutÃ¡vel, como nÃºmeros, strings e tuplas. O tipo set Ã© mutÃ¡vel, o que significa que vocÃª pode adicionar, remover ou atualizar elementos em um conjunto.'''

''' Algumas peculiaridades do tipo set em Python incluem:

> O conjunto nÃ£o mantÃ©m a ordem dos elementos, entÃ£o vocÃª nÃ£o pode acessar os elementos por Ã­ndice.

> O conjunto nÃ£o pode conter elementos duplicados, portanto, se vocÃª tentar adicionar um elemento que jÃ¡ estÃ¡ no conjunto, ele nÃ£o serÃ¡ adicionado novamente.

> VocÃª pode realizar operaÃ§Ãµes de conjunto, como uniÃ£o, interseÃ§Ã£o e diferenÃ§a, usando operadores ou mÃ©todos (|, &, -).

> O conjunto Ã© bastante eficiente para testar se um elemento estÃ¡ presente nele, pois o Python usa uma tabela de hash para pesquisar o elemento.

> VocÃª pode usar mÃ©todos como add(), remove(), discard(), pop() e clear() para adicionar, remover ou atualizar elementos em um conjunto.'''

# Cria um conjunto com alguns elementos
meu_set = {1, 2, 3, "quatro", (5, 6)}

# Adiciona um novo elemento ao conjunto
meu_set.add(7)

# Remove um elemento do conjunto
meu_set.remove(2)

# Imprime o conjunto resultante
print(meu_set)

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Lambda ğŸ“Œ

# Uma lambda Ã© uma funÃ§Ã£o anÃ´nima que pode ser definida em uma Ãºnica linha de cÃ³digo e nÃ£o precisa de um nome associado a ela.

# A sintaxe para definir uma lambda em Python Ã© a seguinte:

lambda argumentos: None

# > Onde argumentos Ã© uma lista separada por vÃ­rgulas de parÃ¢metros que a funÃ§Ã£o espera receber, e None Ã© o resultado que a funÃ§Ã£o deve retornar.

# Por exemplo, se vocÃª quiser definir uma funÃ§Ã£o que recebe um nÃºmero como entrada e retorna o dobro desse nÃºmero, vocÃª poderia fazÃª-lo com a seguinte lambda:

dobro = lambda x: x * 2

# Agora vocÃª pode chamar essa funÃ§Ã£o dobro passando um nÃºmero como argumento e ela retornarÃ¡ o dobro desse nÃºmero:

resultado = dobro(3)
print(resultado)  # SaÃ­da: 6'''

'''As lambdas tambÃ©m podem ser usadas como argumentos de outras funÃ§Ãµes, como no caso da funÃ§Ã£o map(),
 que aplica uma funÃ§Ã£o a cada elemento de uma sequÃªncia e retorna uma nova sequÃªncia com os resultados:'''

numeros = [1, 2, 3, 4, 5]
dobro = lambda x: x * 2
resultado = map(dobro, numeros)
print(list(resultado))  # SaÃ­da: [2, 4, 6, 8, 10]

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Empacotamento e Desempacotamento de DicionÃ¡rios ğŸ“Œ 

''' > O empacotamento de dicionÃ¡rios ocorre quando vocÃª passa um dicionÃ¡rio como argumento para uma funÃ§Ã£o usando o operador ** antes do nome do dicionÃ¡rio. 
Isso faz com que o Python desempacote o dicionÃ¡rio e passe seus pares chave-valor como argumentos nomeados para a funÃ§Ã£o.'''

# Por exemplo, suponha que vocÃª tenha a seguinte funÃ§Ã£o que recebe dois argumentos nomeados:

def minha_funcao(a, b):
    print(f"a = {a}")
    print(f"b = {b}")

# VocÃª pode empacotar um dicionÃ¡rio com os valores para a e b e passÃ¡-lo como argumento para a funÃ§Ã£o usando o operador **:

meu_dict = {'a': 1, 'b': 2}
minha_funcao(**meu_dict)

# Isso Ã© equivalente a chamar a funÃ§Ã£o com os argumentos nomeados diretamente:

minha_funcao(a=1, b=2)

''' > O desempacotamento de dicionÃ¡rios ocorre quando vocÃª atribui os pares chave-valor de um dicionÃ¡rio a variÃ¡veis individuais usando o operador **.
Isso Ã© Ãºtil quando vocÃª deseja passar um dicionÃ¡rio como argumento para uma funÃ§Ã£o que espera argumentos nomeados separados.'''

# Por exemplo, suponha que vocÃª tenha o seguinte dicionÃ¡rio:

meu_dict = {'a': 1, 'b': 2}

# VocÃª pode desempacotar esse dicionÃ¡rio em variÃ¡veis individuais com os nomes correspondentes usando o operador **:

a, b = meu_dict['a'], meu_dict['b']

''' > Observe que, ao desempacotar um dicionÃ¡rio, os nomes das variÃ¡veis devem corresponder exatamente Ã s chaves do dicionÃ¡rio. 
Se o dicionÃ¡rio contiver uma chave que nÃ£o corresponde a uma variÃ¡vel, o Python lanÃ§arÃ¡ uma exceÃ§Ã£o.'''

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ List Comprehension ğŸ“Œ

''' List comprehension Ã© uma tÃ©cnica em Python para criar listas de forma concisa e eficiente. 
Essa tÃ©cnica permite que vocÃª crie uma nova lista baseada em uma ou mais sequÃªncias existentes, ou em outras palavras,
Ã© uma forma de criar uma nova lista aplicando uma operaÃ§Ã£o a cada elemento de uma sequÃªncia.'''

# Se vocÃª quiser criar uma lista com os quadrados dos nÃºmeros de 0 a 9, pode fazer o seguinte:

quadrados = [x**2 for x in range(10)]

# > Nesse caso, a list comprehension cria uma nova lista quadrados contendo os quadrados de cada nÃºmero na sequÃªncia de range(10).

''' Ã‰ possÃ­vel adicionar condiÃ§Ãµes Ã  list comprehension usando uma clÃ¡usula if, onde a condiÃ§Ã£o Ã© uma expressÃ£o booleana que determina 
se o elemento da sequÃªncia serÃ¡ incluÃ­do na nova lista.'''

pares = [x for x in range(10) if x % 2 == 0]

# > Nesse caso, a list comprehension cria uma nova lista pares contendo apenas os nÃºmeros pares da sequÃªncia de range(10).

''' List comprehension tambÃ©m pode ser usado com mÃºltiplas sequÃªncias. Por exemplo, se vocÃª quiser criar uma lista com todas as combinaÃ§Ãµes de nÃºmeros de 0 a 2
e letras de 'a' a 'c', pode fazer o seguinte: '''

combinacoes = [(x, y) for x in range(3) for y in ['a', 'b', 'c']]

# > Nesse caso, a list comprehension cria uma nova lista combinacoes contendo todas as combinaÃ§Ãµes possÃ­veis de nÃºmeros de 0 a 2 e letras de 'a' a 'c'.

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Filtro de Dados em List Comprehension ğŸ“Œ

''' List comprehension tambÃ©m pode ser usado para filtrar dados de uma lista, ou seja, 
criar uma nova lista contendo apenas os elementos que atendem a uma determinada condiÃ§Ã£o.'''

# Por exemplo, se vocÃª quiser criar uma nova lista contendo apenas os nÃºmeros pares de uma lista original, pode usar a seguinte list comprehension:

lista_original = []
numeros_pares = [x for x in lista_original if x % 2 == 0]

# > Nesse caso, a nova lista numeros_pares conterÃ¡ apenas os elementos da lista_original que sÃ£o divisÃ­veis por 2, ou seja, os nÃºmeros pares.

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Dict e Set Comprehension ğŸ“Œ

''' AlÃ©m de list comprehension, Python tambÃ©m suporta dicionÃ¡rio e set comprehension, que sÃ£o construÃ§Ãµes semelhantes Ã  list comprehension, 
mas que criam dicionÃ¡rios e conjuntos em vez de listas.'''

# Por exemplo, se vocÃª quiser criar um dicionÃ¡rio contendo o quadrado de cada nÃºmero de uma lista, pode usar a seguinte dicionÃ¡rio comprehension:

numeros = [1, 2, 3, 4, 5]
quadrados = {x: x**2 for x in numeros}

# > Nesse caso, o novo dicionÃ¡rio quadrados terÃ¡ chaves correspondentes aos elementos da lista numeros e valores correspondentes aos quadrados desses elementos.

# JÃ¡ em set comprehension se vocÃª quiser criar um conjunto contendo apenas os nÃºmeros pares de uma lista, pode usar a seguinte set comprehension:

numeros = [1, 2, 3, 4, 5]
numeros_pares = {x for x in numeros if x % 2 == 0}

# > Nesse caso, o novo conjunto numeros_pares conterÃ¡ apenas os elementos da sequÃªncia que sÃ£o divisÃ­veis por 2, ou seja, os nÃºmeros pares.

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ Isininstance ğŸ“Œ

# Isinstance Ã© uma funÃ§Ã£o embutida do Python que permite verificar se um objeto Ã© de um determinado tipo.

# Por exemplo, para verificar se uma variÃ¡vel x Ã© uma lista, vocÃª pode usar o seguinte cÃ³digo:

x = [1, 2, 3]
if isinstance(x, list):
    print("x Ã© uma lista")
else:
    print("x nÃ£o Ã© uma lista")

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ğŸ“Œ IterÃ¡vel, Iterator e Generator ğŸ“Œ 

'''Um iterÃ¡vel Ã© qualquer objeto que pode ser percorrido por um loop for. 
Exemplos de iterÃ¡veis incluem listas, tuplas, strings, dicionÃ¡rios e conjuntos. 
Esses objetos fornecem um mÃ©todo __iter__() que retorna um iterador, que Ã© usado para percorrer o iterÃ¡vel.

Um iterator Ã© um objeto que produz valores um de cada vez. Ele implementa dois mÃ©todos: __next__() e __iter__().
O mÃ©todo __next__() retorna o prÃ³ximo valor do iterator e levanta a exceÃ§Ã£o StopIteration quando nÃ£o hÃ¡ mais valores para serem produzidos. 
O mÃ©todo __iter__() retorna o prÃ³prio iterator. '''

''' Uma generator expression Ã© uma sintaxe compacta para criar um objeto generator em uma Ãºnica linha de cÃ³digo. 
Ã‰ semelhante a uma list comprehension, mas em vez de criar uma lista, cria um objeto generator.'''

#Por exemplo, a seguinte generator expression cria um generator que produz o quadrado de cada nÃºmero par em uma lista:

numeros = [1, 2, 3, 4, 5]
quadrados_pares = (x**2 for x in numeros if x % 2 == 0)

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------





